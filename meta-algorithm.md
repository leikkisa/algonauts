Steps
1. Understand the problem
2. Come up with example (if one is not provided)
3. Think of edge cases
4. Pseudocode approach - decide on which functions are needed
5. Create function container(s)
6. Implement code
7. Test code
8. Refactor
9. Check edge cases
10. Determine time and space complexity

Types of approaches
1. For loops
2. Do while loops
3. Functional programming (including recursion)
4. Dynamic programming / memoization
5. Hash maps

Types of problems
1. Simple recursive algorithms
2. Backtracking algorithms - depth-first recursive search (countries not next to another country of the same color on a map)
3. Divide-and-conquer algorithms - splits up the problem, uses recursion
4. Dynamic programming algorithms - one subproblem that can be repeatedly solved
5. Greedy algorithms
6. Branch-and-bound algorithms
7. Brute force algorithms

# Interviewer rubric

- interviewee should write down the question
- sample input and output
- ensure that the interviewee writes pseudocode
- check for logic
- thinking out loud
- get to a working solution, then optimize
- whiteboard management
- time management
- indentation
